<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/x-icon" href="./favicon.ico" />
  <!-- 모바일 풀화면/안전영역 -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>EgoIdSuper</title>

  <!-- 번들 CSS: assets/ 또는 같은 폴더 둘 다 시도(404 나도 게임은 동작) -->
  <link rel="stylesheet" href="./assets/index-C9ejXq11.css">
  <link rel="stylesheet" href="./index-C9ejXq11.css">

  <style>
    /* ===== 화면(캔버스) 풀 유지 ===== */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      touch-action: none;
    }
    :root {
      /* visualViewport 기반 실제 높이(주소창/하단바 변동 대응) */
      --appH: 100vh;
      /* HUD 확대 (면적 9배 느낌 = scale 3) */
      --hudScale: 3;
      /* HUD가 너무 크면 2.6~2.8로 낮춰도 됨 */
      --hudPad: 10px;
    }
    #game-container {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: var(--appH);
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
      width: 100% !important;
      height: 100% !important;
    }

    /* ===== 모바일 컨트롤(조이스틱/버튼) 오른쪽 하단 유지 ===== */
    #mobile-controls-container{
      position: fixed !important;
      inset: 0 !important;
      width: 100vw !important;
      height: var(--appH) !important;
      pointer-events: none;
      z-index: 9999;
    }
    #joystick-area{
      left: auto !important;
      right: 0 !important;
      bottom: 0 !important;
      pointer-events: auto;
    }
    /* 버튼 묶음(기본은 오른쪽) */
    #mobile-skill-buttons{
      right: calc(12px + env(safe-area-inset-right)) !important;
      left: auto !important;
      pointer-events: none;
    }

    /* ===== HUD 스케일: "컨테이너만 커져서 화면 밖으로 나가는" 문제 방지 =====
       핵심: scale 적용 + (100%/scale)로 내부 좌표계를 줄여서 최종적으로 화면에 딱 맞게 확대
    */
    #ui-scale-wrapper{
      position: absolute;
      top: 0; left: 0;
      width: calc(100% / var(--hudScale));
      height: calc(100% / var(--hudScale));
      transform: scale(var(--hudScale));
      transform-origin: top left;
      pointer-events: none; /* HUD는 보통 클릭 안 함 */
      padding: var(--hudPad);
      box-sizing: border-box;
    }

    /* HUD 안의 클릭 요소가 있다면 클릭 가능하게 */
    #ui-scale-wrapper button,
    #ui-scale-wrapper [role="button"],
    #ui-scale-wrapper .pointer-events-auto{
      pointer-events: auto;
    }
  </style>
</head>

<body>
  <div id="game-container"></div>

  <script>
    // 실제 보이는 높이를 CSS 변수로 반영(주소창/하단바 변동 대응)
    (function(){
      function setAppH(){
        var h = window.innerHeight;
        if (window.visualViewport && window.visualViewport.height) h = Math.floor(window.visualViewport.height);
        document.documentElement.style.setProperty('--appH', h + 'px');
      }
      window.addEventListener('resize', setAppH, {passive:true});
      window.addEventListener('orientationchange', setAppH, {passive:true});
      if (window.visualViewport) window.visualViewport.addEventListener('resize', setAppH, {passive:true});
      setAppH();
    })();
  </script>

  <script>
    // HUD만 크게: game-ui-container가 만들어진 뒤, 모바일 컨트롤은 제외하고 나머지를 wrapper로 감싸서 스케일
    (function(){
      function wrapAndScaleUI(){
        var ui = document.getElementById('game-ui-container');
        if(!ui) return false;
        if(document.getElementById('ui-scale-wrapper')) return true;

        var wrapper = document.createElement('div');
        wrapper.id = 'ui-scale-wrapper';

        // ui의 "직접 자식" 중, mobile-controls-container는 그대로 두고 나머지는 wrapper로 이동
        var kids = Array.from(ui.children);
        kids.forEach(function(el){
          if (el && el.id === 'mobile-controls-container') return;
          wrapper.appendChild(el);
        });

        // wrapper를 맨 앞에 넣어 HUD가 위에 보이게
        ui.insertBefore(wrapper, ui.firstChild);
        return true;
      }

      // DOM 생성 타이밍 대응
      var tries = 0;
      var t = setInterval(function(){
        tries++;
        if (wrapAndScaleUI() || tries > 200) clearInterval(t);
      }, 50);
    })();
  </script>

  <!-- 번들 JS: assets/ 또는 같은 폴더 둘 다 시도 -->
  <script type="module">
    async function boot(){
      const candidates = [
        "./assets/index-CZje5KUS.js",
        "./index-CZje5KUS.js"
      ];
      for (const src of candidates){
        try{
          await import(src);
          return;
        }catch(e){
          // 다음 후보 시도
        }
      }
      // 둘 다 실패하면 사용자에게 최소 힌트(검은 화면 방지)
      const msg = document.createElement("div");
      msg.style.cssText = "position:fixed;inset:0;display:flex;align-items:center;justify-content:center;color:#fff;font:14px monospace;background:#000;z-index:99999;";
      msg.textContent = "JS 로딩 실패: index-*.js 경로를 확인해주세요 (assets/ 폴더 여부)";
      document.body.appendChild(msg);
      console.error("Failed to load game bundle from candidates.");
    }
    boot();
  </script>

<style id="ui-tune-v3">
  :root{
    --hudScale: 2.8; /* 기본: 2.6~3.0 사이 추천 */
    --hudTop: calc(10px + env(safe-area-inset-top));
    --hudLeft: calc(10px + env(safe-area-inset-left));
    --ctrlPadR: calc(14px + env(safe-area-inset-right));
    --ctrlPadB: calc(14px + env(safe-area-inset-bottom));
    --ctrlGap: 10px;
  }
</style>


<script>
(function(){
  const SCALE = () => parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--hudScale')) || 2.8;

  function isCanvas(el){ return el && el.tagName && el.tagName.toLowerCase() === 'canvas'; }
  function nearTopLeft(r){ return r.top < 80 && r.left < 80; }

  // 1) HUD(왼쪽 상단) 자동 확대: "작은 UI 박스"를 찾아 스케일 적용
  function fixHud(){
    const s = SCALE();
    const candidates = Array.from(document.querySelectorAll('div'))
      .filter(el => !el.id.includes('mobile') && el.id !== 'game-container' && el !== document.body && el !== document.documentElement);

    let best = null, bestScore = -1;

    for(const el of candidates){
      const r = el.getBoundingClientRect();
      if(!nearTopLeft(r)) continue;
      if(r.width < 120 || r.width > 520) continue;
      if(r.height < 40 || r.height > 320) continue;

      // 내부에 img/canvas/span 등이 좀 있는 "HUD" 형태를 가산점
      const score =
        (el.querySelectorAll('img').length * 3) +
        (el.querySelectorAll('canvas').length * 2) +
        (el.querySelectorAll('span,div').length * 0.2) -
        (el.children.length === 0 ? 5 : 0);

      if(score > bestScore){
        bestScore = score;
        best = el;
      }
    }

    if(!best) return false;

    if(best.dataset._hudFixed === "1") return true;
    best.dataset._hudFixed = "1";

    // 스케일 + 화면기준 고정
    best.style.position = 'fixed';
    best.style.top = getComputedStyle(document.documentElement).getPropertyValue('--hudTop').trim() || '10px';
    best.style.left = getComputedStyle(document.documentElement).getPropertyValue('--hudLeft').trim() || '10px';
    best.style.transformOrigin = 'top left';
    best.style.transform = `scale(${s})`;
    // 스케일로 화면 밖으로 튀는 것 방지: 내부 좌표계 축소
    best.style.width = `calc(100% / ${s})`;
    best.style.pointerEvents = 'none';
    best.style.zIndex = '10001';
    return true;
  }

  // 2) 조이스틱을 오른쪽 하단으로 강제: id/class에 joystick이 들어간 요소를 탐색
  function fixJoystick(){
    let joy = document.getElementById('joystick-area')
      || document.querySelector('[id*="joystick" i]')
      || document.querySelector('[class*="joystick" i]');

    if(!joy) return false;
    if(joy.dataset._joyFixed === "1") return true;
    joy.dataset._joyFixed = "1";

    joy.style.position = 'fixed';
    joy.style.right = getComputedStyle(document.documentElement).getPropertyValue('--ctrlPadR').trim() || '14px';
    joy.style.bottom = getComputedStyle(document.documentElement).getPropertyValue('--ctrlPadB').trim() || '14px';
    joy.style.left = 'auto';
    joy.style.top = 'auto';
    joy.style.zIndex = '10000';
    joy.style.pointerEvents = 'auto';
    return true;
  }

  // 3) E/R/AUTO 버튼들을 조이스틱 위로 세로로 정렬 (텍스트 기준)
  function fixActionButtons(){
    const btns = Array.from(document.querySelectorAll('button,div'))
      .filter(el => (el.innerText||'').trim() && ['E','R','AUTO'].includes((el.innerText||'').trim()));

    if(btns.length === 0) return false;

    // 이미 한 번 정리했으면 스킵
    if(document.getElementById('_actionDock')) return true;

    const dock = document.createElement('div');
    dock.id = '_actionDock';
    dock.style.position = 'fixed';
    dock.style.right = getComputedStyle(document.documentElement).getPropertyValue('--ctrlPadR').trim() || '14px';
    dock.style.bottom = `calc(${getComputedStyle(document.documentElement).getPropertyValue('--ctrlPadB').trim() || '14px'} + 160px)`; // 조이스틱 위
    dock.style.display = 'flex';
    dock.style.flexDirection = 'column';
    dock.style.gap = getComputedStyle(document.documentElement).getPropertyValue('--ctrlGap').trim() || '10px';
    dock.style.zIndex = '10000';
    dock.style.pointerEvents = 'none';

    btns.forEach(b=>{
      // 버튼/칩이 div일 수도 있어서 포인터 허용
      b.style.pointerEvents = 'auto';
      dock.appendChild(b);
    });

    document.body.appendChild(dock);
    return true;
  }

  // 반복적으로 잡아주기(로딩 후 생성 타이밍 대응)
  let tries = 0;
  const tick = () => {
    tries++;
    fixHud();
    fixJoystick();
    fixActionButtons();
    if(tries > 240) clearInterval(timer);
  };
  const timer = setInterval(tick, 80);
  setTimeout(tick, 200);
  setTimeout(tick, 800);
})();
</script>

</body>
</html>
